[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Criação de pipelines de análise reprodutíveis em R",
    "section": "",
    "text": "Bem-vindo!",
    "crumbs": [
      "Bem-vindo!"
    ]
  },
  {
    "objectID": "index.html#como-ajudar-cientistas-de-dados-analistas-e-investigadores-a-escrever-código-fiável-com-a-ajuda-de-algumas-ideias-da-engenharia-de-software.",
    "href": "index.html#como-ajudar-cientistas-de-dados-analistas-e-investigadores-a-escrever-código-fiável-com-a-ajuda-de-algumas-ideias-da-engenharia-de-software.",
    "title": "Criação de pipelines de análise reprodutíveis em R",
    "section": "Como ajudar cientistas de dados, analistas e investigadores a escrever código fiável com a ajuda de algumas ideias da engenharia de software.",
    "text": "Como ajudar cientistas de dados, analistas e investigadores a escrever código fiável com a ajuda de algumas ideias da engenharia de software.\n\nCientistas de dados, estatísticos, analistas, investigadores e profissionais similares escrevem muito código.\nNão só escrevem muito código como têm também de ler e rever código. Ou trabalham em equipas e precisam de rever código uns dos outros ou então precisam de reproduzir resultados de projectos antigos, seja no contexto de revisão por pares, seja em auditorias. No entanto, nunca, ou muito raramente, aprenderam técnicas e ferramentas que facilitam o processo de escrita, colaboração, revisão e reprodução de projectos.\nO que é de lamentar, pois os engenheiros de software enfrentam o mesmo tipo de desafios e já foram capazes de resolver este problema há várias décadas.\nO objectivo deste livro é o de mostrar algumas das melhores práticas da engenharia de software e DevOps para tornar os nosso projectos mais robustos, fiáveis e reprodutíveis. Não importa se trabalhamos sozinhos, em equipas pequenas ou grandes. Não importa se o nosso trabalho vai ser revisto por pares ou auditado: as técnicas que aqui serão apresentadas tornarão os nossos projectos mais fiáveis e poupar-nos-ão a muitas frustações.\nEnquanto analistas de dados, somos tentados a pensar que não somos desenvolvedores de código. Os desenvolvedores são aqueles génios que escrevem código de alta qualidade e criam aqueles pacotes de grande utilidade. Mas na verdade, nós também fazemos desenvolvimento de código. A diferença é que o nosso focus reside em escrever código para as nossas análises funcionarem e não para outras pessoas. Pelo menos, esta é a nossa ideia. Nas outras pessoas devemos incluir os nossos colegas de equipa, revisores, auditores, chefias… Todas as pessoas que possam vir a ler o nosso código devem ser incluídas. No mínimo, nós próprios voltaremos a ler o nosso código no futuro.\nAo aprendermos a desenhar projectos e a escrever código de uma forma que futuros usuários possam entender o que foi feito e não nos queiram assassinar, estamos a melhorar a qualidade do nosso trafbalho duma forma natural.\nA abertura de issues, PRs ou outras questões podem ser feitas no repositório deste livro: Github repository1.",
    "crumbs": [
      "Bem-vindo!"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Criação de pipelines de análise reprodutíveis em R",
    "section": "",
    "text": "https://github.com/balima78/rap_pt↩︎",
    "crumbs": [
      "Bem-vindo!"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Prefácio",
    "section": "",
    "text": "Este livro é uma tradução livre de Building reproducible analytical pipelines with R. O autor do livro original, Bruno Rodrigues, tem uma vasto trabalho desenvolvido na área da programação estatística e para nosso deleite tem o bom hábito de partilhar algum do seu trabalho, quer seja através do seu blog, do seu X, do seu canal de youtube ou do seu Github. Depois de nos disponibilizar o ebook Modern R with the tidyverse, fomos agora presenteados com Building reproducible analytical pipelines with R que mostra uma abordagem pragmática de bem programar em estatística.\nO Bruno Rodrigues apresenta-se como lusoburguês, ou seja, é um luxemburguês descendente de portugueses. Também por isto, espero que esta tradução possa também ser vista como uma singela homenagem a tudo o que o Bruno Rodrigues nos tem oferecido.\nDe um ponto de vista mais pessoal, trabalho em estatísca há quase de 25 anos e com R há cerca de uma dúzia de anos, ainda assim encontrei neste livro Building reproducible analytical pipelines with R o meu guia de trabalho e o meu manual de boas práticas. E que melhor forma de estudar este livro do que fazer uma tradução para português?\nMuitos de nós que trabalhmos com dados não temos bases de engenharia de software. A nossa form ação assenta na teoria de probabilidade, algebra linear, algoritmos, alguma programação mas não em engenharia de software. Embora os estatísticos, cientistas de dados (ou como nos queiram chamar atualmente) não sejam engenheiros de software têm de escrever muito código e código muito relevante. No entanto, muitos de nós escrevemos sem regras.\nPor exemplo, quanto do nosso código que produz resultados altamente sensíveis, seja na ciência ou na industria, é devidamente testado? Quanto do código que usamos depende duma só pessoa aparecer no trabalho e que usa um conhecimento secreto que não está documentado? Quanto do código que corremos ninguém se atreve a mexer porque a pessoa que o escreveu originalmente arranjou melhores coisas que fazer?\nEm colaborações com colegas de equipa para produzir um relatório ou um artigo científico consideramos os riscos potencias?\nSomos capazes de dizer exactamente, como um número de um relatório usado por um superior foi produzido? E se houver uma auditoria externa? Serão os aujditores capazes de executar o nosso código sem a nossa intervenção?\nQuando trabalhamos em ciência o nosso trabalho é auditado, ou pelo menos, em teoria, deveria sê-lo. As ideias de open science, open data e reproducibilidade são geralmente bem aceites na comunidade científica, no entanto, na prática, quantos artigos são de facto reprodutíveis? Quantos resultados científicos são auditáveis e rastreáveis?\nO conceito de Pipelines de Análise Reprodutíveis (originalmente, Reproducible Analytical Pipelines) foi desenvolvido pelo Office for National Statistics (ONS). Em 2019, a equipa do ONS responsável pela divulgação deste conceito publicou um ebook gratuito. Deve-se também salientar o trabalho de Software Carpentery, onde encontramos muitas bases que podem ser aplicadas na programação estística.\nResumidamente, aqui podemos encontrar algumas ideias, que embora não sejam novas podem ser do interesse de quem usa o ambiente de programação em R.\nEste livro divide-se em duas partes. A primeira apresenta o conhecimento básico que devemos adquirir para criar pipelines verdadeiramente reprodutíveis, nomeadamente:\n\nControlo de versões com o Git e gestão de projectos com o Github;\nProgramação funcional;\nProgramação letrada.\n\nO principal conceito da Parte 1 é “não te repitas” (“don’t repeat yourself”). O Git e o Github podem-nos ajudar a não perdermos código, nem a perdermos o controlo de quem deve fazer o quê num projecto (mesmo se trabalharmos sozinhos, a utilização do Git e do Github podem-nos econonmizar muitas horas e muitas dores de cabeça). A programação funcional e a programação letrada podem ajudar-nos a melhorar o nosso código evitando duas fontes de erros muito habituais: resultados de computação que dependem do estado do noso programa (e também do estado de todo o hardware que estamos a usar) e os erros de copiar e colar.\nNa segunda parte deste livro utilizaremos os conhecimentos anteriores na utilização de várias ferramentas qua nos ajudarão a ir para lá do controlo de versões e da programa ção funcional e letrada:\n\nGestão de dependencias com {renv};\nDesenvolvimento de pacotes com {fusen};\nTestes unitários e de integração;\nCriação de automação com {targets};\nAmbientes reprodutíveis com Docker;\nIntegração contínua e entrega.\n\nEmbora este não seja um livro para iniciantes (precisamos estar familiarizados com o ambiente de programação R), não assumiremos que temos um conhecimento prévio das ferramentas apresentadas na Parte 2. Na verdade, mesmo que já estejamos familiarizados com Git, Github, programação funcional e letrada, podemos sempre apren der mais alguma coisa com na Parte 1. Mas fica já o aviso, se queremos tirar proveito deste livro vamos ter de escrever muito código.\nMais uma vez quero reforçar que esta é uma tradução livre do exelente trabalho que foi desenvolvido pelo Bruno Rodrigues e não pretende ser uma alternativa ao original.\n\n\n\n\n\nCapa do livro original\n\n\n\n\nMuito pelo contrário, espero que este livro, pelo menos, sirva de incentivo para desbravar Building reproducible analytical pipelines with R.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introdução",
    "section": "",
    "text": "1.1 Para quem é este livro?\nEste livro destina-se a qualquer pessoa que use dados brutos para criar qualquer tipo de resultado com base nesses dados brutos. Pode ser um simples relatório trimestral, por exemplo, no qual os dados são usados para tabelas e gráficos, ou um artigo científico para uma revista com revisão por pares ou até mesmo uma aplicação interativa Web. Não importa, pois o processo é, essencialmente, muito semelhante:\nAssumimos alguma familiaridade com a linguagem de programação R, os exemplos apresentados e as ferramentas usadas são específicas para R. No entanto os conceitos aqui apresentados podem ser aplicados a outras linguagens.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#para-quem-é-este-livro",
    "href": "intro.html#para-quem-é-este-livro",
    "title": "1  Introdução",
    "section": "",
    "text": "Obter os dados;\nLimpar os dados;\nEscrever código para analisar os dados;\nApresentar os resultados num produto final.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#qual-o-objectivo-deste-livro",
    "href": "intro.html#qual-o-objectivo-deste-livro",
    "title": "1  Introdução",
    "section": "1.2 Qual o objectivo deste livro",
    "text": "1.2 Qual o objectivo deste livro\nO objetivo deste livro é tornar o processo de análise de dados o mais fiável, rastreável e reproduzível possível, e fazendo isto por desenho. Ou seja, quando concluirmos a nossa análise, está tudo pronto.\nNão queremos gastar tempo, que geralmente não temos, para reescrever ou formatar uma análise para a tornar reprodutível depois de concluída. Já sabemso que não o vamos fazer! Depois de concluirmos uma análise temos de iniciar um novo projecto. Se precisarmos de executar de novo uma análise mais antiga (por exemplo, porque os dados foram atualizados), na altura preocupar-nos-emos com isso, certo?\nEsperemos que no futuro, nos lembremos de cada peculariedade do nosso código e saibamos qual o script a executar em cada ponto do processso, quais os comentários que estão desatualizados e podem ser ignorados com segurança, que recursos dos dados precisam ser verificados (e quando precisam ser verificados) e assim por diante… É melhor esperar que o futuro seja um trabalhador mais diligente do que nós somos agora!\nDaqui em diante, referir-nos-emos a um projecto reprodutível como um pipeline de análise reprodutível, ou RAP (nas suas siglas em inglês “Reproducible Analytival Pipeline”), para abreviar. Há duas formas de criar esse RAP: ou tems a sorte de contar com algujém cujo trabalho é o de transformar o nosso código num RFAP, ou então temos de ser nós mesmos a fazê-lo. E esta segunda opção é geralmente a mais provável. O problema é que geralmente não o fazemos. Estamos sempre com pressa para chegar aos resultados e não pensamos em tornar o processo reproduzível. Isso ocorre porque pensamos que tornar o processo reproduzível leva tempo e que esse tempo é melhor gasto trabalhando na análise em si. Mas essa é uma concepção errada, por duas ordens de razão.\nPrimeiro a utilização das técnicas discutidas neste livro não con somem muito tempo. Podermos ver, na verdade não são coisas que acrescentamos à análise, mas fazem parte da própria análise e também ajnudam na gestgão do projecto. E algumas dessas técnicas nos ajudarão a economizar tempo (especialmente nos testes) e dores de cabeça.\nDepois a análise nunca é feita de uma só vez. Apenas coisas mais simples serão feitas apenas uma única vez, como extrair um va lor de uma base de dados. Ainda assim, é provável que depois de darmos esse número, sejamos solicitados para obtermos a variação desse número (por exemplo desagregando por uma ou várias variáveis). Ou talvez nos peçam para atualizarmos aquele número passado meio ano. Assim, procuramos gauardar a consulta SQL em algum script a que possamos recorrer para darmos uma resposta consistente. Mas e no caso de análises mais complexas? manter o mesmo script pode ser um bom princípio (quando temos esse script) mas não é suficiente.\nNão raras vezes, estamos na situação em que, temos de atualizar um relatório, passado um ano, em que estão envolvidas várias pessoas no processo e só a parte da recolha dos novos dados já é uma complicação. Porque uns têm os dados duma maneira e outros doutra… Bom, a primeira lição (e se calhar a mais importante) deste livro é: ao iniciarmos a construção de um RAP, devemos garantir que falamos com todas as pessoas que vão estar envolvidas no processo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#pré-requisitos",
    "href": "intro.html#pré-requisitos",
    "title": "1  Introdução",
    "section": "1.3 Pré-requisitos",
    "text": "1.3 Pré-requisitos\nDevemos estar familiarizados com o ambiente de programação em R. Ao longo deste livro, vamos assumir que usamos o R em vários projectos e que queremos melhorar não só o uso da linguagem em si mas principalmente como devemos gerir projectos complexos. Sabemos o que são pacotes e como instalá-los, já escrevemos algumas funções em R, sabe mos o que são loops, e sabemos quais são as estruturas de dados que podemos usar (como por exemplo as listas). Também estamos familiarizados com a visualização, processamento e análise de dados, embora estes não sejam temas do livro.\nNão usaremos qualquer tipo de Graphical User Interface (GUI) mas sim um IDE como o RStudio. Isto porque a interação com um GUI não é reprodutível. O nosso objectivo é o de escever código que possa ser executado não-interactivamente por uma máquina. Isto porque uma condição necessária para que um fluxo de trabalho seja reprodutível e designado como RAP é que o fluxo de trabalho possa ser executado por uma máquina, automaticamente, sem nenhuma intervenção humana. Esta é a segunda lição para a criação de RAPs: não deve haver nenhuma intervenção humana necessária para obter os resultados depois que o RAP for iniciado. Se conseguirmos isto, o nosso fluxo de trabalho provavelmente é reprodutível ou, pelo menos, poderá ser reproduzido mais facilmente do que se exigir alguma manipulação por um ser humano em algum momento do ciclo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#reproducibilidade",
    "href": "intro.html#reproducibilidade",
    "title": "1  Introdução",
    "section": "1.4 Reproducibilidade",
    "text": "1.4 Reproducibilidade\nUm projecto reprodutível é aquele que pode ser executado repetidamente por qualquer pessoa e sem esforço (ou com um esforço mínimo). Porém, há diferentes níveis de reproducibilidade, como veremos nesta secção. Vejamos alguns requisitos que um projectodeve ter para ser um RAP.\n\n1.4.1 Usar ferramentas open-source\nO código-fonte aberto é um requisito rígido para a reproducibilidade.\nNão há “se” nem “mas”. Não nos referimos apenas ao código que escrevemos para o nosso artigo de pesquisa/relatório/análise. Todo o ecossistema que usamos para digitar o nosso código e criar o fluxo de trabalho tem de ser open-source.\nSe é código escrito num programa proprietário, como STATA, SAS ou SPSS, então não é um RAP. Não importa se o código está bem documentado, escrito e disponível num sistema de controlo de versões (internamente na nossa empresa ou aberto ao público). Esse projeto simplesmente não é reproduzível. Por quê? Porque, num horizonte de tempo longo o suficiente, não há como reexecutar o nosso código com a mesma versão exata da linguagem de programação proprietária e na mesma versão exata do sistema operacional que foi usado no momento em que o projeto foi desenvolvido.\n\n\n1.4.2 Dependências ocultas que poem em causa a reproducibilidade\nMas há outro problema: vamos supor que temos escrito um bom fluxo de trabalho, testado exaustivamente, bem documentado, disponibilizado no Github (e vamos supor que os dados estão também disponíve is para download gratuito e ainda que o artigo é de acesso aberto). Vamos supor ainda que o código foi escrito em R ou Python. Podemos então dizer que estga análise ou estudo é reprodutível? Bem, se a análise foi executada num sistema operacional proprietário, então não é reprodutível. Isto porque o sistema operacional em que o código é executado também pode influenciar os resultados que o pipeline gera. Há algumas particularidades nos sistemas operacionais que podem fazer com que certas coisas funcionem de forma diferente. É certo que, na prática, isso raramente é um problema, mas acontece1, especialmente se estivermos a trabalhar com aritmética de ponto flutuante de alta precisão, como acontece no setor financeiro, por exemplo.\nFelizmente, não há necessidade de mudarmos de sistema operacional para lidarmos com este problema. Podemos usar o Docker como salvaguarda.\n\n\n1.4.3 Requisitos para um RAP\nResumidamente, para termos algo verdadeiramente reprodutível, tem de respeitar os eguintes pontos:\n\nObviamente, o código-fonte deve estar disponível e ser exaustivamente testado e documentado (e é por isso que usaremos o Git e o Github);\nTodas as dependências devem ser fáceis de encontrar e instalar (vamos lidar com isso usando ferramentas de gerenciamento de dependências);\nSer escrito com uma linguagem de programação de código aberto (ferramentas nocode como o Excel são, por padrão, não reprodutíveis porque não podem ser usadas de forma não interativa, e é por isso que usaremos a linguagem de programação R);\nO projeto precisa ser executado em um sistema operacional de código aberto (felizmente, podemos lidar com isso sem ter de instalar e aprender a usar um novo sistema operacional, graças ao Docker);\nObviamente, os dados e o documento/relatório também precisam estar acessíveis, se não publicamente, como é o caso duma investigação, então dentro da nossa empresa. Isso significa que o conceito de “scripts e/ou dados disponíveis mediante solicitação” deve ir para o lixo.\n\n\n\n\n\n\nUma frase real de um artigo real publicado no THE LANCET Regional Health. E se disponibilizares os dados e eu não risco o teu carro, que tal isso como uma solicitação razoável?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#há-diferentes-tipos-de-reproducibilidade",
    "href": "intro.html#há-diferentes-tipos-de-reproducibilidade",
    "title": "1  Introdução",
    "section": "1.5 Há diferentes tipos de reproducibilidade?",
    "text": "1.5 Há diferentes tipos de reproducibilidade?\nVamos dar um passo atrás: vivemos no mundo real e, no mundo real, há algumas restrições que estão fora do nosso controle. Essas restrições podem impossibilitar a criação de um RAP verdadeiro, portanto, às vezes, precisamos nos contentar com algo que pode não ser um RAP verdadeiro, mas uma segunda ou até terceira melhor opção.\nNo que se segue, vamos supor o seguinte: na discussão em baixo, o código é testado e documentado, portanto, vamos discutir apenas o código que executa o pipeline em si.\nO pior pipeline reprodutível seria algo que funcionasse, mas somente na nossa máquina. Isso pode ser simplesmente devido ao fato de termos codificado caminhos que só existem no nosso laptop. Qualquer pessoa que queira executar novamente o pipeline precisará alterar os caminhos. Isto é algo que precisa ser documentado em um README, o que presumimos ser o caso, então é isso. Mas talvez esse pipeline só seja executado no nosso laptop porque o ambiente computacional que estamos a u sar é difícil de reproduzir. Talvez estamos a usar um software, mesmo que seja um software de código aberto, que não seja fácil de instalar (qualquer pessoa que tenha tentado instalar pacotes R no Linux que dependem do pacote {rJava} percebe este exemplo).\nPortanto, um pipeline menos mau seria aquele que pudesse ser executado mais facilmente em qualquer máquina semelhante à nossa. Isso poderia ser feito não usando caminhos absolutos codificados e fornecendo instruções para configurar o ambiente. Por exemplo, no caso do R, isso poderia ser tão simples quanto fornecer um script chamado install_deps.R que seria uma chamada para install.packages(). Poderia ser assim:\n\ninstall.packages(c(\"package1\",\n                   \"package2\",\n                   etc))\n\nNeste caso, o problema é que precisamos de nos certificar de que as versões corretas dos pacotes sejam instaladas. Se o nosso script usa {ggplot2} versão 2.2.1, os usuários devem instalar essa versão também e, ao executar o script acima, a versão mais recente de {ggplot2} será instalada. Talvez isto não seja um problema, mas pode ser que o nosso script use uma função da versão 2.2.1 que já não esteja disponível na versão mais recente (ou talvez o nome tenha sido alterado, ou talvez tenha sido modificado de alguma forma e não forneça exatamente o mesmo resultado). Quanto mais pacotes o script usar (e quanto mais antigo elee forem), maior será a probabilidade de que alguma versão do pacote não seja compatível. Há também a questão da própria versão do R. De modo geral, as versões recentes do R parecem não ser tão más a executar códigos mais antigos escritos em R.\nMas importar sublinhar que quando corremos um código antigo e não nos dá erro, não significa que os resultados sejam exactamente iguais. Pode haver casos que a mesma função devolva resultados diferentes em diferentes versões do R. Ou seja, não basta contar com a estabilidade da própria linguagem de programaçãoao longo do tempocomo con dição suficiente para a reproducibilidade.\nIsto significa que a reproducibilidade é um continuum e , dependendo das restrições que tenhamos, o nosso projecto pode ser ‘não muito reprodutível’ ou ‘totalmente reprodutível’. Assim, o grau de reproducibilidade do nosso projecto pode ser influenciado por:\n\nVersão da linguagem de programação usada;\nVersões dos pacotes da referida linguagem de programação utilizada;\nSistema operacional e sua versão;\nVersões das bibliotecas do sistema subjacente (que geralmente andam de mãos dadas com a versão do sistema operacional, mas não necessariamente).\nE até mesmo a arquitetura de hardware na qual executamos todo o software.\n\nPortanto, quando dizemos que a “reproducibilidade é um continuum”, significa que podemos implementar o nosso projecto de modo a que nenhum, um, dois, três ou todos os items anteriores são considerados, para que seja reprodutível.\nEsta não é uma ideia nova ou inédita. Peng (2011) já discutiu este conceito a que chamou de “espectro de reproducibilidade”. Na segunda parte deste livro, voltaremos a esta ideia que designaremos como “iceberg de reproducibilidade”.\n\n\n\n\n\nO espectro de reproducibilidade do artigo de 2011 de Peng.\n\n\n\n\nMesmo quando falamos de arquitectura de hardware, esta também não é imutável. A Apple mudou a arquitectura dos seus compuradores recentemente, e no futuro a Microsoft também pode pressionar os fabricantes OEM a criarem mais computadores baseados em ARM.\nMas então como podemos gerir todos estes riscos e equilibrar a necessidade imediata de resultados com a necessidade futura de executar novamente um projeto antigo? E se a retoma desse projeto antigo nunca for necessária no futuro?\nÉ aqui que este livro nos pode ajudar, ao usarmos as técnicas discutidas aqui, tornaremos fácil e rápida a configuração dum projecto desde o início para que seja realmente reprodutível. Ao criarmos o projecto desta forma também garantirá que evitaremos erros e resultados errados. Será mais fácil e rápido iterar e melhorar o nosso código, colaborar com terceiros e confiar nos resultados do nosso pipeline. Mesmo que ninguém volte a executar o nosso código, poderemos beneficiar das boas práticas aqui recomendadas.\n\n\n\n\nPeng, Roger D. 2011. “Reproducible Research in Computational Science.” Science 334 (6060): 1226–27.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introdução",
    "section": "",
    "text": "https://github.com/numpy/numpy/issues/9187↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "part1_intro.html",
    "href": "part1_intro.html",
    "title": "Parte 1: Don’t Repeat Yourself",
    "section": "",
    "text": "Introdução\nNesta primeira parte, vamo-nos focar nos ingredientes principais da reproducibilidade. E por ingredientes principais referimo-nos às ferramentas indispensáveis na nossa caixa de ferramentas que devemos de ter antes de tentarmos sequer fazer um projecto reprodutível. Estas ferramentas são tão importantes que lhes didicaremos uma grande parte deste livro:\nMesmo que já estejamos familiarizados com estes tópicos e mesmo que os utilizamos no nosso dia-a-dia, vale a pena espreitarmos para esta Parte 1 do livro antes de abordarmos a Parte 2. Na segunda parte o focus recairá noutro conjunto de ferramentas que permitem criar os RAP.\nOu seja, nesta primeira parte não vamos a aprender a construir RAPs mas n ão podemos saltar para a criação de RAPs antes de comprendermos os conceitos supracitados.\nVamos começar por analisar alguns con juntos de dados. Fazer o download, limpar os dados e fazer alguns gráficos. Isto será feito em dois scripts, escritos duma forma comum sem “engenharia de software”, para assim replicarmos a forma como analistas de dados, cientistas de dados ou investigadores, que não têm qualquer tipo de form ação em ciência de computação, fazem este tipo de análises. Ou seja, estes programadores têm como objectivo principal a entraga rápida de resultados, sem olhar a meios.\nPoderemos então mostrar que adotando algumas ideias simples da engebnharia de software, podemos obter resultados tão rápidos quanto antes mas duma forma mais con sistente e robusta.",
    "crumbs": [
      "Parte 1: Don't Repeat Yourself"
    ]
  },
  {
    "objectID": "part1_intro.html#introdução",
    "href": "part1_intro.html#introdução",
    "title": "Parte 1: Don’t Repeat Yourself",
    "section": "",
    "text": "Controlo de versões;\nProgramação funcional;\nProgramação letrada.",
    "crumbs": [
      "Parte 1: Don't Repeat Yourself"
    ]
  },
  {
    "objectID": "part2_intro.html",
    "href": "part2_intro.html",
    "title": "Parte 2: Write IT Down",
    "section": "",
    "text": "O iceberg da reproducibilidade\nvamos refletir um pouco sobre a primeira parte do livro e porque é que ainda não falamos de nada directamente relacionado com a reproducibilidade.\nNa introdução falamos sobre o continuum ou o espectro da reproducibilidade e agora vamos detalhar este conceito. Chamemos-lhe o iceberg da reproducibilidade:\nO iceberg da reproducibilidade.\nPorquê iceberg? Porque as partes do iceberg que vemos, são óbvias, são como executarmos as nossas análises num ambiente baseado em cliques, como o Excel. Isto é, não é necessário nenhum conhecimento especial mnem mesmo nenhuma formação específica. Apenas precisamos de tempo, pelo que quem usa estas ferramentas não .é eficiente e portanto tendem a compensar com muitas horas de trabalho.\nVamos um nível mais abaixo e escrever um guião. Foi aqui que começamos. O nosso script nem é assim tão mau, fazia o que pretendíamos. Ao contrário do fluxo de trabalho baseado em cliques, pelo menos podemos relê-lo, outras pessoas podem lê-lo, e até seria possível executá-lo no futuro, ainda que com algum esforço e com um pouco de sorte. Para que este script possa se executado no futuro com êxito, não pode depender de pacotes com atualizações que ponham em causa o código (por exemplo, funções que são renomeadas). Além disso, se esse script depender de uma fonte de dados, os autores originais também terão de garantir que a mesma fonte de dados continua disponível. Outro problema são as colaborações ao escrever esse script. Sem nenhuma ferramenta de controle de versões nem plataforma de hospedagem de código, a colaboração neste script pode se transformar rapidamente em um pesadelo.\nÉ aqui que o Git e Github entram em acção, num nível mais profundo. Temos a vantagem que a colaboração foi simplificada. O histórico de alterações está disponível para todos os elementos da equipe e é possível reverter alterações, experimentar novos recursos usando ramificações e gerir o projeto de modo geral. Neste níveltambém usamos novos paradigmas de programação para tornar o código do projeto menos verboso, usando a programação funcional, com os benefícios adicionais de facilitar o teste, a documentação e a partilha (que discutiremos em sua plenitude nesta parte do livro). Usando a programação letrada, também é muito mais fácil chegar ao nosso resultado final (que geralmente é um relatório). Exploramos ao máximo as ideias DRY, para garantir que nosso código seja de alta qualidade.\nMas, se o orçamento e o tempo permitirem, ainda podemos ir mais fundo, e definitivamente devemos fazê-lo. No futuro podemos querer atualizar o nosso script para usarmos a funcionalidade mais recente do nosso pacote preferido mas com a gravação da versão do pacote, ficamos limitados a uma versão muito antiga e às suas dependências. Como podemos saber que ao atualizarmos aquele pacote não partimos o nosso fluxo de trabalho? Além disso, queremos tornar a execução do script o mais fácil possível e, idealmente, o nemos interactivo possível. Na verdade, qualquer interação humanacom na análise é uma fonte de erros. É por isso que precisamos de testar o nosso código de uma forma completa e sistemática. E esses testes também pecisam de ser executados duma forma não interactiva. Com as ferramentes que usaremos nesta segunda parte, podemos, de facto, configurar o nosso projecto, desde o início, de modo a que seja reprodutível naturalmente. Usando as ferramentas certas e configurando as coisas correctamente, não precisamos realmente de investir mais tempo para tornar o processo reprodutível. O projeto simplesmente será reprodutível porque foi desenhado dessa forma. Praticamente sem nenhum custo adicional!\nOutro problema de apenas registarmos a versão dos pacotes utilizados é que às vezes isso não é suficiente. Isto porque a instalação de pacotes antigos pode ser desafiante por dois motivos:\nPara resolvermos este problema precisamos congelar o próprio ambiente computacional, e para isto usaremos o Docker.\nPor fim, e este é o último nível do iceberg que não faz parte deste livro, é também necessário tornar a construção do ambiente computacional reprodutível. O Guix é a ferramenta que permite fazer exatamente isso. No entanto, esse é um tópico muito profundo por si só, e há soluções alternativas para conseguir isso usando o Docker, por isso não falaremos sobre o Guix.\nNos próximos capítulos, vamos percorrer o iceberg. Primeiro, vamos reescrever nosso projeto usando programação funcional e letrada. O nosso projecto não será composto por dois scripts mas sim por dois ficheiros de Rmarkdown que podemos executar para se sejam legíveis e partilháveis com quaisquer partes interessadas.\nEm seguida, transformaremos esses dois ficheiros .Rmd num pacote. Isso será feito usando o pacote de Sébastien Rochette {fusen}1. O {fusen} facilita muito a passagem dos nossos ficheiros .Rmd para um pacote, usando o que Sébastien chamou de método Rmarkdown first.\nUma vez que tenhamos o nosso pacote, podemos usar o {testthat} para fazermos testes unitários, e funções do R base para fazermos programação assertiva. Nesta fase o nosso código deverá estar bem documentado, fácil de partilhar, e amplamente testado.\nComeçámos com scripts muito simples, que é como a maioria das análises é feita. Em seguida, usando programação funcional e letrada, esses scripts foram transformados em ficheiros RMarkdown e, nesta parte do livro, esses ficheiros RMarkdown serão transformados em um pacote. É claro que, no futuro, podemos começar imediatamente a partir dos ficheiros RMarkdown ou do pacote. Devemos começar pelo pacote, pois, como veremos, começar pelo pacote é basicamente o mesmo esforço que começar por um arquivo RMarkdown simples, graças a {fusen}, mas agora temos os benefícios adicionais de usar os recursos de desenvolvimento de pacotes para melhorar a nossa análise.\nDepois de termos o pacote podemos criar um verdadeiro pipeline usando {targets}, um pacote incrivelmente útil para automatizar a compilação.\nChegados a este ponto, podemos finalmente falar em reproducibilidade mais concretamente. O motivo porque demoramos tanto tempo a chegar aqui é que para tornamos o nosso pipeline reprodutível precisamos de bases sólidas. Não faz sentido tornar reprodutível uma análise que é instável.",
    "crumbs": [
      "Parte 2: Write IT Down"
    ]
  },
  {
    "objectID": "part2_intro.html#o-iceberg-da-reproducibilidade",
    "href": "part2_intro.html#o-iceberg-da-reproducibilidade",
    "title": "Parte 2: Write IT Down",
    "section": "",
    "text": "Pacotes antigos podem precisar de versões antigas do R, e a isntalação de versões antigas do R pode ser complidaca (dependendo do sistema operacional que tivermos);\nOs pacotes mais antigos podem precisar de ser compilados e, consequentemente, dependem de versões mais antigas de bibliotecas de desenvolvimentonecessárias paar a compilação.",
    "crumbs": [
      "Parte 2: Write IT Down"
    ]
  },
  {
    "objectID": "part2_intro.html#footnotes",
    "href": "part2_intro.html#footnotes",
    "title": "Parte 2: Write IT Down",
    "section": "",
    "text": "https://thinkr-open.github.io/fusen/↩︎",
    "crumbs": [
      "Parte 2: Write IT Down"
    ]
  },
  {
    "objectID": "repro_intro.html",
    "href": "repro_intro.html",
    "title": "10  Reproducibilidade básica: congelar pacotes",
    "section": "",
    "text": "10.1 Gravar as versões dos pacotes com {renv}\nAgora que já usamos a programação funcional e letrada, temos de começar a pensar sobre a insfraestrutura que rodeia o nosso código. Ou seja:\nO {renv} permite-nos criar ambientes reprodutíveis, tratando do segundo ponto. Isto é, permite-nos registar os pacotes que foram usados num determinado projecto. Este registo é um ficheiro designado renv.lock que aparece na raíz do nosso projecto quando executamos o {renv}. Podemos usar o {renv} depois de fazermos a análise (como neste caso), ou imediatamente depois de iniciarmos o nosso projecto. Podemos atualizar o renv.lock à medida que formos adicionando ou removendo pacotes à nossa análise. O ficheiro renv.lock pode ser usado para restaurar exatamente a mesma livraria de pacotes usada na nossa análise, noutro computador, ou no nosso, num futuro.\nIsto funciona porque o {renv} faz mais do que manter uma lista dos pacotes usados e das suas versões, no ficheiro renv.lock. Na verdade é criada uma livraria por projecto que fica completamente isolada da livraria principal do R que temos na nossa máquina, mas também de outras livrarias que possamos ter criado com o {renv}. Para nos poupar tempo, ao criamos a livraria {renv}, os pacotes são copiados da livraria principal em vez de serem baixados e re-instalados (se o pacote usado já está instalado na nossa livraria principal).\nComeçamos então por instalar pacote {renv}:\ninstall.packages(\"renv\")\na partir da pasta onde temos os nossos ficheiros Rmd que fizemos no capítulo anterior:\ne depois de garantirmos que as últimas alterações já estão em Github (se não estiverem fazemos o commit e o push para o branch rmd), criamos um novo branch designado como renv porque vamos experimentar uma nova funcionalidade, ou seja:\ne agora trabalharemos neste novo branch como habitualmente, garantindo que antes de fazermos push estamos no branch renv:\nAgora apenas temos de reiniciar a sessão do R e executar o comando:\nrenv::init()\ndeveremos ver qualquer coisa como:\n* Initializing project ...\n* Discovering package dependencies ... Done!\n* Copying packages into the cache ... [76/76] Done!\nThe following package(s) will be updated in the lockfile:\n\n# CRAN ===============================\n***and then a long list of packages***\n\nThe version of R recorded in the lockfile will be updated:\n- R              [*] -&gt; [4.2.2]\n\n* Lockfile written to 'path/to/housing/renv.lock'.\n* Project 'path/to/housing' loaded. [renv 0.16.0]\n* renv activated -- please restart the R session.\nvamos espreitar os ficheiros que criamos:\nComo podemos ver, temos dois novos ficheiros e uma nova pasta. Os novos ficheiros são o já referido renv.lock e o .Rprofile. A nova pasta tem o nome renv. O renv.lock é o ficheiro que lista os pacotes usados na nossa análise. O ficheiro .Rprofile tem os ficheiros que são lidos pelo R automaticamente no arranque. Devemos ter um ficheiro de sistema que é lido pelo R no arranque, mas se o R detecta um ficheiro .Rprofile na directoria em que é iniciado, então é este ficheiro que é lido. Vejamos o conteúdo deste ficheiro.\nO ficheiro tem apenas uma linha:\nO script activate.R na pasta renv foi criado pelo renv::init(). Vejamos todo o conteúdo desta pasta:\nNa pasta renv, temos outra pasta library: esta é a pasta que tem a livraria isolada para o nosso projecto. Não queremos fazer backup a esta pasta, nem a queremos passar para o Github, pois tende a crescer muito rapidamente. Podemos ver também que temos o ficheiro .gitignore que contém caminhos para outros ficheiros e pastas às quais não queremos fazer backup e que devem ser ignorados pelo Git. Se abrirmos o .gitignore podemos ver que temos lá a pasta library/ listada para ser ignorada. Podemos ter tantos ficheiros .gitignore quantos quiseremos mas se tivermos um na raíz do projecto este é aplicado a todo o projecto.\nPor exemplo, se estivermos a trabalhar com dados sensíveis, podemos criar um ficheiro .gitignore no directório do nosso projecto e listar a pasta que tem os dados sensíveis. Podemos criar este ficheiro com um simples editor de texto e para este exemplo apenas escrevemos:\nAssim, garantimos que o conteúdo desta pasta será ignorado pelo Git e não passará para o Github.\nVamos reiniciar uma nova sessão do R, no directório do nosso projecto; deveremos ver a seguinte mensagem de início:\n* Project 'path/to/housing' loaded. [renv 0.16.0]\nIsto significa que esta sessão do R usará os pacotes instalados na livraria isolada que acabamos de criar. Vejamos o ficheiro renv.lock:\nO renv.lock é um ficheiro JSON que lista todos os pacotes, bem como as suas dependências, usados neste projecto. No início do ficheiro está a versão R usada para gerar este renv.lock. É importante relembrar que quando usamos o {renv} para recuperar uma livraria dum projecto numa nova máquina, a versão do R não será restaurada. Ou seja, no futuro poderemos restaurar este projecto com versões antigas de pacotes que usaremos numa versão mais nova do R, o que pode gerarn problemas.\nE é isto… Geramos um ficheiro renv.lock o que significa que nós no futuro ou outra pessoa poderá usar a livraria que usamos neste projecto. Para isto apenas é necessário que a outra pessoa (ou nós no futuro) instale o {renv} e use o ficheiro renv.lock que criamos, para restaurar a livraria. Vejamos como é que isto funciona, clonando o repositório Github deste link (que por sua vez é um fork daqui1))\nDeveremos ver a pasta tagets-minimal no nosso computador e depois de iniciarmos uma sessão do R nesta pasta, temos de executar o comando:\nrenv::restore()\nSomos então questionados sobre a activação deste projecto:\nThis project has not yet been activated.\nActivating this project will ensure the project library\nis used during restore.\nPlease see `?renv::activate` for more details.\n\nWould you like to activate this project before restore? [Y/n]:\nteclamos em Y e deveremos ver a lista de pacotes que precisam de ser instalados. Seremos questionados mais uma vez se queremos continuar e teclando y poderemos ver os pacotes a serem instalados. Se repararmos nos links, veremos que muitos são baixados do arquivo do CRAN, por exemplo:\nPodemos ver a palavra Archive no url. Isto acontece porque a versão usada do {vroom} neste projecto não é a mais recente.\nAinda assim, há a possibilidade de fazermos renv::restore() e a instalação dos pacotes falhar. Vejamos o exemplo em que tentamos restaurar uma livraria em dois computadores diferentes, um Windows e um Linux. No primeiro caso o renv::restore() falhou e no segundo foi bem sucedido. Isto aconteceu porque a compilação do pacote {dplyr} falhou no caso do Windows provavelmente por não ter a versão correcta do Rtools instalada. Ou seja, se no ficheiro renv.lock estiver registado a versão 4.1.0 do R mas depois quisermos restaurar a livraria num computador com a versão 4.2.2, os pacotes serão compilados com o Rtools 4.2 e não com o Rtools 4.0 (que também compila livrarias para o R 4.1). Assim, neste caso para não termos problemas em restaurar a livraria no novo Windows teriamos de instalar primeiro as versões correctas do R e do Rtools.\nIsto não quer dizer que o {renv} é inútil, pelo menos serve para garantir que atualizações de livrarias não interferem nos nossos projectos anteriores. Ou seja, podemos trabalhar em vários projectos simultaneamente e termos a certeza de que se atualizamos a nossa livraria (por exemplo para podermos usar uma nova função de um determinado pacote), isto só afecatará a livraria em que este pacote foi atualizado e não as outras livrarias dos outros projectos. Quando trabalhamos apenas com uma livraria para todo o sistema, a atualização de um pacote pode fazer falhas noutros projectos, quer seja porque atualizamos também outro pacote inadevertidamente ou porque uma qualquer função que também foi atualizada neste processo mudou de nome ou passou a usar parametros diferentes. Podemos evitar este tipo de problemas se usarmos sempre uma livraria por projecto com o {renv}.\nPara além desta característica, o ficheiro renv.lock também fornece uma impressão digital muito útil para o Docker e que abordaremos num próximo capítulo. Resumidamente, como o renv.lock regista a versão do R utilizado, podemos logo começar com uma imagem Docker que contenha a versão correcta do R e a partir daqui já não deveremos ter problemas ao fazermos o renv::restore().\nPodemos então usar o {renv} em duas situações:",
    "crumbs": [
      "Parte 2: Write IT Down",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Reproducibilidade básica: congelar pacotes</span>"
    ]
  },
  {
    "objectID": "repro_intro.html#gravar-as-versões-dos-pacotes-com-renv",
    "href": "repro_intro.html#gravar-as-versões-dos-pacotes-com-renv",
    "title": "10  Reproducibilidade básica: congelar pacotes",
    "section": "",
    "text": "a versão do R;\nos pacotes usados para a análise;\ne todo o ambiente computacional, incluindo o próprio hardware.\n\n\n\n\n\n\n\nsave_data.Rmd, o script que faz o download e prepara os dados;\nanalyse_data.Rmd, o script que faz a análise dos dados.\n\n\nowner@localhost ➤ git checkout -b renv\n\nowner@localhost ➤ git add .\nowner@localhost ➤ git commit -m \"some changes\"\nowner@localhost ➤ git push origin renv\n\n\n\n\n\nowner@localhost ➤ ls -la\ntotal 1070\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:44 .\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:35 ..\n-rw-r--r-- 1 owner Domain Users    27 Feb 27 12:44 .Rprofile\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:40 .git\n-rw-r--r-- 1 owner Domain Users   306 Feb 27 12:35 README.md\n-rw-r--r-- 1 owner Domain Users  2398 Feb 27 12:38 analyse_data.Rmd\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:44 renv\n-rw-r--r-- 1 owner Domain Users 20502 Feb 27 12:44 renv.lock\n-rw-r--r-- 1 owner Domain Users  6378 Feb 27 12:38 save_data.Rmd\n\nowner@localhost ➤ cat .Rprofile\n\nsource(\"renv/activate.R\")\n\nowner@localhost ➤ ls -la renv\ntotal 107\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:44 .\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:35 ..\n-rw-r--r-- 1 owner Domain Users    27 Feb 27 12:44 activate.R\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:40 .gitignore\ndrwxr-xr-x 1 owner Domain Users     0 Feb 27 12:40 library\n-rw-r--r-- 1 owner Domain Users  6378 Feb 27 12:38 settings.dcf\n\n\ndatasets/\n\n\n\n\nowner@localhost ➤ cat renv.lock\n{\n\"R\": {\n  \"Version\": \"4.2.2\",\n  \"Repositories\": [\n  {\n   \"Name\": \"CRAN\",\n   \"URL\": \"https://packagemanager.rstudio.com/ all/latest\"\n  }\n  ]\n},\n\"Packages\": {\n  \"MASS\": {\n    \"Package\": \"MASS\",\n    \"Version\": \"7.3-58.1\",\n    \"Source\": \"Repository\",\n    \"Repository\": \"CRAN\",\n    \"Hash\": \"762e1804143a332333c054759f89a706\",\n    \"Requirements\": []\n  },\n  \"Matrix\": {\n    \"Package\": \"Matrix\",\n    \"Version\": \"1.5-1\",\n    \"Source\": \"Repository\",\n    \"Repository\": \"CRAN\",\n    \"Hash\": \"539dc0c0c05636812f1080f473d2c177\",\n    \"Requirements\": [\n      \"lattice\"\n    ]\n\n    ***and many more packages***\n\n\nowner@localhost ➤ git clone git@github.com:b-rodrigues/targets-minimal.git\n\n\n\n\n\nRetrieving 'https://cloud.r-project.org/src/contrib/Archive /vroom/vroom_1.5.5.tar.gz'\n\n\n\n\n\n\nConcluimos o nosso projecto e apenas queremos registar os pacotes usados. Basta então executar renv::init() no final do projecto, fazemos commit e o push do ficheiro renv.lock para o Github.\nUsamos o {renv} logo ao iniciarmos o nosso projecto para assim isolarmos uma livraria para o projecto e evitarmos interferências de outras livrarias do R.\n\n\n10.1.1 Uso corrente do {renv}\nNo caso de querermos usar o {renv} logo quando iniciamos um novo projecto, podemos seguir este exemplo. Começamos numa nova directoria e adicionamos um template .Rmd como este:\n---\ntitle: \"My new project\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nlibrary(dplyr)\n``\n\n## Overview\n\n## Analysis\nAntes de continuarmos, verificamos que compila num ficheiro HTML, na nossa directoria, executando:\n\nrmarkdown::render(\"test.Rmd\")\n\nNo chunk de setup definimos os pacotes que vamos usar e depois de reiniciarmos a sessão do R na mesma directoria podemos executar renv::init(). Devemos a gora ver as questões que já referias em cima e por fim um ficheiro renv.lock (com o pacote {dplyr} e as suas dependências).\nAgora se adicionarmos a linha libraray(ggplot2) ao chunk de setup gravarmos o nosso .Rmd e voltarmos a compilar rmarkdown::render(\"test.Rmd) vamos ter a seguinte mensagem de erro:\nQuitting from lines 7-9 (my_new_project.Rmd)\nError in library(ggplot2) : there is no package called 'ggplot2'\nUma vez que temos o {renv} ativado e consequentemente temos uma livraria específica para este projecto temos de instalar o pacote {ggplot2} antes de o usarmos (ainda que já possa estar instalado na livraria do nosso sistema). Para o instalarmos apenas temos de reiniciar a sessão do R e executamos install.packages(\"ggplot2\"). Se a versão disponível na livraria do nosso sistema for a mais actual então apenas será copiada para a livraria do nosso projecto, caso contrário será instalada a versão mais actual que estiver no CRAN. Podemos agora atualizar o ficheiro renv.lock com o comando renv::snapshot(). Lista dos pacotes a serem registados no renv.lock:\n\n**list of many packages over here**\n\nDo you want to proceed? [y/N]: \n* Lockfile written to 'path/to/my_new_project/renv.lock'.\n\nSe abrirmos o ficheiro renv.lock e procurarmos por \"ggplot2\" veremos esta pacote listado junto com as suas dependências. Esta versão do {ggplot2} é única para o nosso projecto, podemos usar outras versões do {ggplot2} em outros projectos sem que tenham interferência neste. Se por qualuer motivo não quisermos usar a versão mais recente de um qualquer pacote no nosso projecto podemos instalar uma outra versão, ainda graças ao {renv}. Por exemplo, para instalarmos uma versão antiga do {AER}, apenas temos de executar:\n\nrenv::install(\"AER@1.0-0\") # this is a version from August 2008\n\nAinda assim a instalação de versões antigas de pacotes pode dar erros e veremos em próximos capítulos como contornar estes potenciais erros.\nSempre que instalamos mais pacotes necessários para o nosso projecto, temos de executar renv::snapshot(), para adicionarmos estes pacotes ao renv.lock. No final do nosso projecto devemos sempre executar renv::snapshot() para garantirmos que não nos esquecemos de nenhum pacote. Depois é só fazer o devido commit e o push para termos o backup do ficheiro renv.lock.\n\n\n10.1.2 Colaborar com o {renv}\nO {renv} tabém pode ser muito útil em trabalho colaborativo. Ao iniciarmos o projecto geramos o ficheiro renv.lock e quando o projecto for clonado por outros colaboradores já terá as versões correctas dos pacotes a serem usados. No entanto todos os colaboradores devem garantir que trabalham com a mesma versão do R para evitarem problemas de maior. Fica aqui uma vinheta que explica isto mesmo.\n\n\n10.1.3 Atalhos do {renv}\nPor muito útil que seja o {renv} há sempre alguns atalhos que importa sublinhar. Devemos perceber o que o {renv} faz e também o que não faz. E porque é que o {renv} apenas não é suficiente para garantirmos a reproducibilidade do nosso projecto.\nO primeiro problema (como já referimos) reside no facto do renv.lock apenas registar a versão do R que é usada e não a restaura quando usamos o renv::restore(). Temos que ser nós próprios a instalarmos a versão correcta do R. No Windows isto não é difícil, o problema é quando temos a necessidade de usar versões diferentes do R em projectos diferentes, o que pode ser confuso.\nO pacote {rig} pode facilitar a instalação e a troca entre versões do R tal como descrito aqui2. Mas a forma mais segura deverá ser o Docker que abordaremos mais à frente.\nOutro problema do {renv} é que a instalção de versões antigas de pacotes pode ser problemática. Por exemplo, se precisarmos de especificidades do sistema que nos estejam limitadas por falta de permissões de administrador, para instalarmos versões mais antigas, pomos em causa a reproducibilidade do nosso projecto. Mais uma vez o Docker pode resolver este problema. No futuro apenas precisariamos de correr um contentor Docker que é muito mais simples do que instalar algumas versões antigas de pacotes.\nRegistemos também que no desenvolvimento do nosso projecto podemos ter a necessidade de atualizarmos alguns pacotes para melhorarmos a qualidade dos nossos scripts. Podemos fazer isto com update.packages() e depois com renv::snapshot() para gerarmos um novo ficheiro renv.lock. Mas como podemos ter a certeza que estas atualizações não deitam a perder outras partes do nosso código? Transformar a nossa análise num pacote pode ajudar-nos a garantir que não temos quebras pois será mais fácil de definirmos testes para o nosso código. Se os testes indicarem que algo correu mal, apenas temos de recuperar o ficheiro renv.lock anterior com a ajuda do Git e voltamos a restaurar a livraria antiga.\nPodemos usar o {renv} junto com o Docker para garantirmos a reproducilbilidade do nosso projecto, sendo que o ficheiro renv.lock nos dá a impressão digital para construirmos a imagem Docker para uma reproducibilidade a longo prazo.\nMas e se não tivermos um ficheiro renv.lock, como podemos executar uma análise antiga?",
    "crumbs": [
      "Parte 2: Write IT Down",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Reproducibilidade básica: congelar pacotes</span>"
    ]
  },
  {
    "objectID": "repro_intro.html#o-arqueologista",
    "href": "repro_intro.html#o-arqueologista",
    "title": "10  Reproducibilidade básica: congelar pacotes",
    "section": "10.2 O aRqueologista",
    "text": "10.2 O aRqueologista\nImaginemos que temos de executar um script antigo para o qual não temos um ficheiro renv.lock que nos permita saber que versões de R e dos pacotes temos de instalar. Ainda assim pode haver uma solução (que não seja executar tudo e rezar para que não dê erros) mas temos de saber pelo menos em que altura é que o script foi escrito. Digamos que o script foi escrito em 2017, por volta de outubro. Com esta informação, podemos usar os pacotes {rang} ou {groundhog} para fazermos o download dos pacotes de outubro de 2017 para uma livraria em separado e depois correremos o script.\nA utilização do {rang} está documentada num prepint3 (Chan and Schoch 2023) e no seu repositório4 no Github.\nA outra opção é usar o {groundhog} (website5). Esta opção já não é nova e é de fácil utilização. Suponhamos que temos um script de outubro de 2017 como este:\n\nlibrary(purrr)\nlibrary(ggplot2)\n\ndata(mtcars)\n\nmyplot &lt;- ggplot(mtcars) +\n  geom_line(aes(y = hp, x = mpg))\n\nggsave(\"/home/project/output/myplot.pdf\", myplot)\n\nSe quisermos executar este script com versões do {purrr} e {ggplot2} que eram atuais em outubro de 2017, podemos fazê-lo apenas alterando library() por:\n\ngroundhog::groundhog.library(\"\n    library(purrr)\n    library(ggplot2)\",\n    \"2017-10-04\"\n    )\n\ndata(mtcars)\n\nmyplot &lt;- ggplot(mtcars) +\n  geom_line(aes(y = hp, x = mpg))\n\nggsave(\"/home/project/output/myplot.pdf\", myplot)\n\nmas vamos ter a seguinte mensagem:\n-----------------------------------------------\n|IMPORTANT.\n|    Groundhog says: you are using R-4.2.2, but the version of R current\n|    for the entered date, '2017-10-04', is R-3.4.x. It is recommended\n|    that you either keep this date and switch to that version of R, or\n|    you keep the version of R you are using but switch the date to\n|    between '2022-04-22' and '2023-01-08'.\n|\n|    You may bypass this R-version check by adding:\n|    `tolerate.R.version='4.2.2'`as an option in your groundhog.library()\n|    call. Please type 'OK' to confirm you have read this message.\n|   &gt;ok\nO {grounghog} sugere-nos que devemos mudar para a versão do R que era usada na altura que o script foi escrito. Se quisermos ignorar a mensagem de aviso, podemos adicionar o parâmetro tolerate.R.version = '4.2.2', e talvez consigamos que o script corra na mesma:\n\ngroundhog.library(\"\n    library(purrr)\n    library(ggplot2)\",\n    \"2017-10-04\",\n    tolerate.R.version = \"4.2.2\")\n\ndata(mtcars)\n\nmyplot &lt;- ggplot(mtcars) +\n  geom_line(aes(y = hp, x = mpg))\n\nggsave(\"/home/project/output/myplot.pdf\", myplot)\n\nMas tal como o {renv}, com o {rang} a instalação dos pacotes pode falhar e pelas mesmas razões já referidas.\nDe novo, a solução é tratarmos da peça no puzzle da reproducibilidade que é o próprio ambiente computacional.",
    "crumbs": [
      "Parte 2: Write IT Down",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Reproducibilidade básica: congelar pacotes</span>"
    ]
  },
  {
    "objectID": "repro_intro.html#conclusão",
    "href": "repro_intro.html#conclusão",
    "title": "10  Reproducibilidade básica: congelar pacotes",
    "section": "10.3 Conclusão",
    "text": "10.3 Conclusão\nNeste capítulo tivemos a primeira amostra da reproducibilidade. As ferramentas aqui apresentadas, embora sejam muito úteis, não são suficientes se quisermos o nosso projecto verdadeiramente reprodutível, especialmente a longo prazo. Há muitas coisas que podem correr mal quando pretendemos instalar versões antigas de pacotes, pelo que temos de arranjar maneiras de não o fazermos. É aqui que o Docker pode ser útil. Mas antes disso temos de voltar ao nosso projecto e transformar a nossa análise num pacote. E como poderemos ver, isto será fácil, uma vez que já temos 95% do trabalho feito.\n\n\n\n\nChan, Chung-hong, and David Schoch. 2023. “RANG: Reconstructing Reproducible r Computational Environments.” arXiv.",
    "crumbs": [
      "Parte 2: Write IT Down",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Reproducibilidade básica: congelar pacotes</span>"
    ]
  },
  {
    "objectID": "repro_intro.html#footnotes",
    "href": "repro_intro.html#footnotes",
    "title": "10  Reproducibilidade básica: congelar pacotes",
    "section": "",
    "text": "https://is.gd/AAnByB↩︎\nhttps://is.gd/dvH2Sj↩︎\nhttps://arxiv.org/abs/2303.04758↩︎\nhttps://is.gd/sQu7NV↩︎\nhttps://groundhogr.com↩︎",
    "crumbs": [
      "Parte 2: Write IT Down",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Reproducibilidade básica: congelar pacotes</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Chan, Chung-hong, and David Schoch. 2023. “RANG: Reconstructing\nReproducible r Computational Environments.” arXiv.\n\n\nPeng, Roger D. 2011. “Reproducible Research in Computational\nScience.” Science 334 (6060): 1226–27.",
    "crumbs": [
      "References"
    ]
  }
]